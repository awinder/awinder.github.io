<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: npm | The Attic]]></title>
  <link href="http://awinder.github.io/blog/categories/npm/atom.xml" rel="self"/>
  <link href="http://awinder.github.io/"/>
  <updated>2014-01-21T20:48:15-05:00</updated>
  <id>http://awinder.github.io/</id>
  <author>
    <name><![CDATA[Andrew Winder]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Structuring Library Functionality in Node.js Projects]]></title>
    <link href="http://awinder.github.io/blog/2013/10/15/structuring-local-node-modules/"/>
    <updated>2013-10-15T22:05:00-04:00</updated>
    <id>http://awinder.github.io/blog/2013/10/15/structuring-local-node-modules</id>
    <content type="html"><![CDATA[<p>Recently I needed to start thinking about adding reusable &ldquo;library&rdquo; components to an <a href="http://www.expressjs.com">Express.js</a> node.js project, and I hit a bit of a brick wall.  The library functionality was fairly specific to the application, and it just doesn&rsquo;t make that much sense to break it out as seperately-packaged module right now.  Seems like a fairly common use-case, right?  Well, apparently not.  You can load any filepath through the <code>require()</code> system, like so:</p>

<p><div><script src='https://gist.github.com/8552134.js?file=app.js'></script>
<noscript><pre><code>var module = require('./lib/myModule');
...</code></pre></noscript></div>
</p>

<p>But where this can quickly become a nuisance is when you are nested down a deep folder hierarchy:</p>

<p><div><script src='https://gist.github.com/8552134.js?file=itemModel.js'></script>
<noscript><pre><code>var module = require('../../../lib/myModule');
...
</code></pre></noscript></div>
</p>

<p>Having to track the folder hierarchy is a little bit of an inconvience, especially when compared to the convience of the <a href="https://npmjs.org">NPM</a> module system.  Searching around for some solutions, I found issues with the approaches commonly suggested:</p>

<ul>
<li><strong>Modify the paths where require.js scans for modules</strong> &ndash; In <a href="http://nodejs.org/docs/v0.4.1/api/all.html#loading_from_the_require.paths_Folders">previous versions</a> of node, it looks like you could modify the paths require.js searched through, but this method has been deprecated and was not a &ldquo;best practice&rdquo; while available.</li>
<li><strong>Load the path to your library directory into a global</strong> &ndash; I wanted to figure out a way around needing to declare some application-wide globals.  doing something like this might also create some unit testing concerns.</li>
<li><strong>Utilize <a href="https://npmjs.org/doc/link.html">npm-link</a></strong> &ndash; This seemed great at first blush, but the actual mechanics of how npm-link works are a little perculiar.  Npm-link first symlinks a specified module in your project directory to the global npm module location.  Then, it&rsquo;s symlinks that global location to a module in your local project&rsquo;s node_modules directory.  This means naming collisions could occur if you tried to use this method with two projects on the same machine.</li>
<li><strong>Just put your library modules in the node_modules directory!</strong> &ndash; Right now, this project&rsquo;s node_modules directory only includes community packages, and they&rsquo;re all installed through <code>package.json</code>.  This provides nice separation in the code &mdash; <code>node_modules</code> is not our code, everything else is.  The node_modules directory is actually ignored in source control to disuade developers from mucking around with our open-source libraries.</li>
</ul>


<p>Npm-link got me thinking though, and a <a href="http://mathematism.com">co-worker</a> clued in on that too.  We could create a &ldquo;library&rdquo; module, which acted mostly as a namespace for our project&rsquo;s unique library-type functionality.  Each of those unique pieces would be submodules of the &ldquo;library&rdquo; module.  Then, we can create a symlink from the node_modules directory to the library directory, and commit that symlink into our source control.  Now our code can look like this:</p>

<p><div><script src='https://gist.github.com/8552134.js?file=newItemModel.js'></script>
<noscript><pre><code>var module = require('lib/myModule');
...
</code></pre></noscript></div>
</p>

<p>We get the benefits of keeping our code outside of the node_modules directory, but with the benefits of it living within the <code>require()</code> lookup path.  It&rsquo;s working out great so far, and I&rsquo;m happy we ended up finding a very straightforward solution to our problem.</p>

<p><img src="/images/posts/2013-10-15-structuring-local-node-modules/folder-structure.png" alt="Example folder structure" /></p>
]]></content>
  </entry>
  
</feed>
