<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[The Attic]]></title>
  <link href="http://awinder.github.io/atom.xml" rel="self"/>
  <link href="http://awinder.github.io/"/>
  <updated>2014-01-20T23:31:34-05:00</updated>
  <id>http://awinder.github.io/</id>
  <author>
    <name><![CDATA[Andrew Winder]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unit Testing Express.js Routes]]></title>
    <link href="http://awinder.github.io/blog/2014/01/20/unit-testing-express-dot-js-routes/"/>
    <updated>2014-01-20T22:00:00-05:00</updated>
    <id>http://awinder.github.io/blog/2014/01/20/unit-testing-express-dot-js-routes</id>
    <content type="html"><![CDATA[<p>Unit testing of model-type functionality in Node has been really straightforward for me so far.  By injecting mocks using wonderful libraries like <a href="https://github.com/thlorenz/proxyquire">Proxyquire</a>, you can smoothly control flow and trigger conditional branches while testing to ensure that you&rsquo;re fully covering a module.  But what happens when you need to test out <a href="http://expressjs.com">Express.js</a> route handlers?  Imagine you have configured a route in an Express.js application like so:</p>

<div><script src='https://gist.github.com/7508239.js?file=index.js'></script>
<noscript><pre><code>var express = require('express')
  , app = exports = module.exports = express()
  , ctrl = require('./controller');

app.get('/', ctrl.test);
</code></pre></noscript></div>


<p>And imagine you have a controller that implements the callback you configured your application with for the &ldquo;/&rdquo; endpoint:</p>

<div><script src='https://gist.github.com/7508239.js?file=controller.js'></script>
<noscript><pre><code>module.exports = {
  test : function(req, res) {
    setTimeout(function() {
      res.send({ testing : true }, 200);
    }, 5000);
  },
}
</code></pre></noscript></div>


<p>The timeout here isn&rsquo;t exactly practical, but it is representative:  Most non-trivial functionality in an Express.js project is going to need to communicate with some system, like a database or caching system, or read from the file system.  In other words:  Something asynchronous!  Asynchronous code is much less straightforward to test because a unit test needs to have some kind of idea when the code you&rsquo;re testing is done.  Unlike testing a synchronous function, which returns to signify that it&rsquo;s completed, you just can&rsquo;t do that with asynchronous logic.  Further complicating this situation is that Express route handlers signal that they are done by calling a method on the Response object, like res.send.  This is a little different from situations where I&rsquo;ve tested my own modules (usually in models) because the events that my models emit are easily subscribed to in the tests.  I can wait for the events to fire in a unit test, inspect any data that is in the event, and then exit the unit test.  What&rsquo;s the right move here?</p>

<p>It&rsquo;s actually relatively straightforward:  I just need to inject a mock Response object into the route handler.  By injecting a mock, I can have some control over what happens once the methods on the response are called.  Because response methods are often called in asynchronous workflows, I&rsquo;ll want a mock that emits an event itself.  Lets see what that might look like:</p>

<div><script src='https://gist.github.com/7508239.js?file=response.mock.js'></script>
<noscript><pre><code>var util = require('util')
  , events = require('events').EventEmitter;

var res = function () {
};

util.inherits(res, events);

res.prototype.send = function(payload, code) {
  this.emit('response', {
    code: code,
    response: payload
  });
}

module.exports = function() {
  return new res();
};</code></pre></noscript></div>


<p>Hopefully this looks as expected.  I&rsquo;m utilizing the EventEmitter prototype that Node.JS provides, and now when the response object&rsquo;s <em>send</em> method is invoked, I fire a <em>response</em> event.  That way, in the unit test, I can attach an event handler to the mock&rsquo;s event, and then kick off the route handler method that I want to test.  Whenever the response methods are actually invoked, the handler in the unit test will invoke, and there we can perform any assertions on the output of our controller&rsquo;s action: the response code and response body.</p>

<div><script src='https://gist.github.com/7508239.js?file=test.spec.js'></script>
<noscript><pre><code>var expect = require('chai').expect
  , res = require('./mocks/response')()
  , testing = require('./controller');

describe('Testing', function(){
  it('Should send an object with a testing key', function(done){
    res.on('response', function(resp) {
      expect(resp.response).to.have.property('testing');
      expect(resp.response.testing).to.equal(true);
      done();
    });
    
    testing.test({}, res);
  });
});
</code></pre></noscript></div>


<p>And just like that, my route handler has unit test coverage.  As the controller gets built out, we&rsquo;ll want to use tools like <a href="https://github.com/thlorenz/proxyquire">Proxyquire</a>, as mentioned before, to inject mocks for our external resources to keep our tests running smoothly and to not duplicate testing efforts.  A unit test for a route handler should exist primarily to test any branching logic or business logic that exists inside the handler itself: Not the branching logic and business logic in the route handlers <em>dependencies</em>.  We try to keep our logic pretty light inside of route handler itself at work, but there are some situations, like in error reporting, where we do branch.  These situations are definitely not trivial, and it&rsquo;s important that we have appropriate testing coverage for it.  And now, we have a straightforward and repeatable method for doing that testing.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Structuring Library Functionality in Node.js Projects]]></title>
    <link href="http://awinder.github.io/blog/2013/10/15/structuring-local-node-modules/"/>
    <updated>2013-10-15T22:05:00-04:00</updated>
    <id>http://awinder.github.io/blog/2013/10/15/structuring-local-node-modules</id>
    <content type="html"><![CDATA[<p>Recently I needed to start thinking about adding reusable &ldquo;library&rdquo; components to an <a href="http://www.expressjs.com">Express.js</a> node.js project, and I hit a bit of a brick wall.  The library functionality was fairly specific to the application, and it just doesn&rsquo;t make that much sense to break it out as seperately-packaged module right now.  Seems like a fairly common use-case, right?  Well, apparently not.  You can load any filepath through the <code>require()</code> system, like so:</p>

<figure class='code'><figcaption><span>app.js </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./lib/myModule&#39;</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>But where this can quickly become a nuisance is when you are nested down a deep folder hierarchy:</p>

<figure class='code'><figcaption><span>resources/items/models/itemModel.js </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;../../../lib/myModule&#39;</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Having to track the folder hierarchy is a little bit of an inconvience, especially when compared to the convience of the <a href="https://npmjs.org">NPM</a> module system.  Searching around for some solutions, I found issues with the approaches commonly suggested:</p>

<ul>
<li><strong>Modify the paths where require.js scans for modules</strong> &ndash; In <a href="http://nodejs.org/docs/v0.4.1/api/all.html#loading_from_the_require.paths_Folders">previous versions</a> of node, it looks like you could modify the paths require.js searched through, but this method has been deprecated and was not a &ldquo;best practice&rdquo; while available.</li>
<li><strong>Load the path to your library directory into a global</strong> &ndash; I wanted to figure out a way around needing to declare some application-wide globals.  doing something like this might also create some unit testing concerns.</li>
<li><strong>Utilize <a href="https://npmjs.org/doc/link.html">npm-link</a></strong> &ndash; This seemed great at first blush, but the actual mechanics of how npm-link works are a little perculiar.  Npm-link first symlinks a specified module in your project directory to the global npm module location.  Then, it&rsquo;s symlinks that global location to a module in your local project&rsquo;s node_modules directory.  This means naming collisions could occur if you tried to use this method with two projects on the same machine.</li>
<li><strong>Just put your library modules in the node_modules directory!</strong> &ndash; Right now, this project&rsquo;s node_modules directory only includes community packages, and they&rsquo;re all installed through <code>package.json</code>.  This provides nice separation in the code &mdash; <code>node_modules</code> is not our code, everything else is.  The node_modules directory is actually ignored in source control to disuade developers from mucking around with our open-source libraries.</li>
</ul>


<p>Npm-link got me thinking though, and a <a href="http://mathematism.com">co-worker</a> clued in on that too.  We could create a &ldquo;library&rdquo; module, which acted mostly as a namespace for our project&rsquo;s unique library-type functionality.  Each of those unique pieces would be submodules of the &ldquo;library&rdquo; module.  Then, we can create a symlink from the node_modules directory to the library directory, and commit that symlink into our source control.  Now our code can look like this:</p>

<figure class='code'><figcaption><span>resources/items/models/itemModel.js </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;lib/myModule&#39;</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>We get the benefits of keeping our code outside of the node_modules directory, but with the benefits of it living within the <code>require()</code> lookup path.  It&rsquo;s working out great so far, and I&rsquo;m happy we ended up finding a very straightforward solution to our problem.</p>

<p><img src="http://awinder.github.io/images/posts/2013-10-15-structuring-local-node-modules/folder-structure.png" alt="Example folder structure" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's In the Attic]]></title>
    <link href="http://awinder.github.io/blog/2013/10/13/whats-in-the-attic/"/>
    <updated>2013-10-13T16:34:00-04:00</updated>
    <id>http://awinder.github.io/blog/2013/10/13/whats-in-the-attic</id>
    <content type="html"><![CDATA[<p>Hello World!  Welcome to the Attic, that musty place containing the out-of-season or otherwise discarded riff-raff of your life.  Or in this case, the random musings and technical discussions of Andrew Winder, a web engineer at Message Systems in Columbia, MD.  I&rsquo;m primarily focused on the areas of PHP API development and well-structured <a href="http://www.angularjs.org">Javascript</a> on the client-side right now, along with <a href="https://en.wikipedia.org/wiki/NoSQL">non-rdbms</a> data storage design and <a href="http://www.nodejs.org">server-side javascript</a> slowly commanding more and more of my attention.  As I continue to explore these areas of technology, I&rsquo;ve found myself wanting somewhere to collect and gather my thoughts, and record my experiences designing and building solutions using these tools.  This blog will serve as that somewhere, that place to gather and store my thoughts, so that one day someone might find some use for them.  My attic.</p>

<p>Along with acting as a place to purely write though, this blog will also act as an experimental playground for front-end development as well.  I&rsquo;m utilizing <a href="http://jekyllrb.com">Jekyll</a> as a static-site generator of these posts and listing pages, <a href="http://twitter.github.io/bootstrap/">Twitter Bootstrap</a> as a CSS framework, and <a href="http://fortawesome.github.io/Font-Awesome/">FontAwesome</a> to provide iconography across the site.  I&rsquo;ll be sure not to break things as I go along, but I&rsquo;ve taken a first stab at a responsive design that seems to make sense to me across various device breakpoints.  That may not be the last stab, though.  This site will also evolve as I continue to actually write out posts.  Right now, with one post, RSS feeds don&rsquo;t make much sense, but if I can get into a good rhythm of posting updates, that&rsquo;ll be next up.  Figuring out better tag paging support might come after that.</p>

<p>That about wraps up my introduction to this site.  Please feel free to ping me over the social media links on this site with any feedback, suggestions, or requests you might have!</p>

<p>-Andy, <a href="http://www.twitter.com/awinder">@awinder</a></p>
]]></content>
  </entry>
  
</feed>
